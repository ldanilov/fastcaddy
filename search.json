[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "fastcaddy",
    "section": "",
    "text": "Install from pypi\n$ pip install fastcaddy",
    "crumbs": [
      "fastcaddy"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "fastcaddy",
    "section": "",
    "text": "Install from pypi\n$ pip install fastcaddy",
    "crumbs": [
      "fastcaddy"
    ]
  },
  {
    "objectID": "index.html#installing-caddy",
    "href": "index.html#installing-caddy",
    "title": "fastcaddy",
    "section": "Installing Caddy",
    "text": "Installing Caddy\nThis project is to help you use the caddy API, rather than a Caddyfile, to use caddy. To use the API, you need to install a plugin for your domain management service. We use Cloudflare, so we’ll document that here. For other domain services, see the Caddy docs for other plugins.\n\nCloudflare setup\n\nfrom fastcore.utils import *\n\nYou’ll need a token from Cloudflare with access to modify the necessary settings. Here’s the steps to create a token with the minimal privileges. You’ll need to install the cloudflare pip package, then import:\n\nfrom cloudflare import Cloudflare\n\nThen you’ll need create a Cloudflare API token for your user, which we’ll then use to create the less privileged token.\n\ncf_token = os.environ['CLOUDFLARE_API_TOKEN']\n\nWe can now check that works OK:\n\ncf = Cloudflare(api_token=cf_token)\nzones = cf.zones.list()\nlen(zones.result)\n\n8\n\n\nReplace this with your domain name:\n\ndomain = 'answer.ai'\nzones = cf.zones.list(name=domain)\nassert len(zones.result)==1\n\n\nzone_id = zones.result[0].id\n\nHere’s the methods available for modifying DNS records:\n\nclient.dns.records.create(*, zone_id, **params) -&gt; Optional\nclient.dns.records.update(dns_record_id, *, zone_id, **params) -&gt; Optional\nclient.dns.records.list(*, zone_id, **params) -&gt; SyncV4PagePaginationArray[Record]\nclient.dns.records.delete(dns_record_id, *, zone_id) -&gt; Optional\nclient.dns.records.edit(dns_record_id, *, zone_id, **params) -&gt; Optional\nclient.dns.records.export(*, zone_id) -&gt; str\nclient.dns.records.get(dns_record_id, *, zone_id) -&gt; Optional\nclient.dns.records.import\\_(*, zone_id, **params) -&gt; Optional\nclient.dns.records.scan(*, zone_id, **params) -&gt; Optional\n\n…and here’s the methods for tokens:\nfrom cloudflare.types.user import (CIDRList, Policy, Token, TokenCreateResponse, TokenUpdateResponse, TokenListResponse,\n                                   TokenDeleteResponse, TokenGetResponse, TokenVerifyResponse)\n\nclient.user.tokens.create(**params) -&gt; Optional\nclient.user.tokens.update(token_id, **params) -&gt; object\nclient.user.tokens.list(**params) -&gt; SyncV4PagePaginationArray[object]\nclient.user.tokens.delete(token_id) -&gt; Optional\nclient.user.tokens.get(token_id) -&gt; object\nclient.user.tokens.verify() -&gt; Optional\n\nfrom cloudflare.types.user.tokens import PermissionGroupListResponse\n\nclient.user.tokens.permission_groups.list() -&gt; SyncSinglePage[object]\n\nfrom cloudflare.types.user.tokens import Value\n\nclient.user.tokens.value.update(token_id, **params) -&gt; str\n\nWe need these two permissions in our token:\n\npermission_groups = cf.user.tokens.permission_groups.list()\n\ndns_write = next(group for group in permission_groups if group['name'] == 'DNS Write')\nzone_read = next(group for group in permission_groups if group['name'] == 'Zone Read')\n\nNow we can create it:\nnew_token = cf.user.tokens.create(\n    name='caddy_dns',\n    policies=[{\n        \"effect\": \"allow\",\n        \"resources\": { f\"com.cloudflare.api.account.zone.{zone_id}\": \"*\" },\n        \"permission_groups\": [\n            {\"id\": zone_read['id'], \"name\": \"Zone Read\"},\n            {\"id\": dns_write['id'], \"name\": \"DNS Write\"}\n        ]\n    }]\n)\n\nprint(new_token.value)\nMake a copy of this value, which we’ll need for setting up caddy.\n\n\nInstalling caddy\nTo install caddy, we’ll use a tool called xcaddy. This is written in go. So first install go:\n\nMac: brew install go\nLinux: sudo apt install golang\n\nNow we can install xcaddy:\ngo install github.com/caddyserver/xcaddy/cmd/xcaddy@latest\nThen we use that to compile caddy with our desired domain plugin (cloudflare, in this case):\ncd ~/go/bin\n./xcaddy build --with github.com/caddy-dns/cloudflare\nThis gives us a ~/go/bin/caddy binary we can run:\n./caddy version\n./caddy run\n\n\nSecurely run caddy on start\nIf you’re using a server or running caddy a lot, you’ll want it to run on start. And if you’re making it publicly accessible, you’ll want it to be secure. This isn’t needed otherwise – you can just ~/go/bin/caddy run to run it manually (you may want to add ~/go/bin to your PATH env var).\nTo set this up, run from this repo root:\n./setup_service.sh\nIf all went well, you should see output like this:\n● caddy.service - Caddy\n     Loaded: loaded (/etc/systemd/system/caddy.service; enabled; preset: enabled)\n     Active: active (running) since Sat 2024-11-09 05:06:47 UTC; 2 days ago\n       Docs: https://caddyserver.com/docs/\n   Main PID: 138140 (caddy)\n      Tasks: 29 (limit: 154166)\n     Memory: 19.3M (peak: 28.8M)\n        CPU: 3min 37.216s\n     CGroup: /system.slice/caddy.service\n             └─138140 /usr/bin/caddy run --environ",
    "crumbs": [
      "fastcaddy"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "fastcaddy",
    "section": "How to use",
    "text": "How to use\nWe will now show how to set up caddy as a reverse proxy for hosts added dynamically. We’ll grab our token from the previous step (assuming here that it’s stored in an env var):\n\ncf_token = os.environ.get('CADDY_CF_TOKEN', 'XXX')\n\nWe can now setup the basic routes needed for caddy:\n\nsetup_caddy(cf_token)\n\nTo view the configuration created, use gcfg:\n\ngcfg()\n\n{ 'apps': { 'http': { 'servers': { 'srv0': { 'listen': [':80', ':443'],\n                                             'routes': []}}},\n            'tls': { 'automation': { 'policies': [{'issuers': [{'challenges': {'dns': {'provider': {'api_token': 'XXX', 'name': 'cloudflare'}}}, 'module': 'acme'}]}]}}}}\n\n\nYou can also view a sub-path of the configuration:\n\ngcfg('/apps/http/servers')\n\n{'srv0': {'listen': [':80', ':443'], 'routes': []}}\n\n\nTo add a reverse proxy, use add_reverse_proxy:\n\nhost = 'jph.answer.ai'\nadd_reverse_proxy(host, 'localhost:5001')\n\nThis is automatically added with an id matching the host, which you can view with gid:\n\ngid('jph.answer.ai')\n\n{ '@id': 'jph.answer.ai',\n  'handle': [{'handler': 'reverse_proxy', 'upstreams': [{'dial': 'localhost:5001'}]}],\n  'match': [{'host': ['jph.answer.ai']}],\n  'terminal': True}\n\n\nIf you call this again with the same host, it will be replaced:\n\nadd_reverse_proxy(host, 'localhost:8000')\ngid('jph.answer.ai').handle[0]\n\n{'handler': 'reverse_proxy', 'upstreams': [{'dial': 'localhost:8000'}]}\n\n\nTo remove a host, delete its id:\n\ndel_id(host)",
    "crumbs": [
      "fastcaddy"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "API",
    "section": "",
    "text": "source\n\n\n\n get_id (path)\n\nGet a ID full URL from a path\n\nhost = 'jph.answer.ai'\n\n\nget_id('jph.answer.ai')\n\n'http://localhost:2019/id/jph.answer.ai/'\n\n\n\nsource\n\n\n\n\n get_path (path)\n\nGet a config full URL from a path\n\nget_path('/apps/tls/automation/policies')\n\n'http://localhost:2019/config/apps/tls/automation/policies/'\n\n\n\nsource\n\n\n\n\n gid (path='/')\n\nGets the id at path\n\nsource\n\n\n\n\n has_id (id)\n\nCheck if id is set up\n\nsource\n\n\n\n\n gcfg (path='/', method='get')\n\nGets the config at path\n\nsource\n\n\n\n\n has_path (path)\n\nCheck if path is set up\n\ngcfg()\n\n{ 'apps': { 'tls': { 'automation': { 'policies': [{'issuers': [{'challenges': {'dns': {'provider': {'api_token': 'yxeyTR9lZY9e265KHtoVjhMI23lh586PLBz1NxaA', 'name': 'cloudflare'}}}, 'module': 'acme'}]}]}}}}\n\n\n\nsource\n\n\n\n\n pid (d, path='/', method='post')\n\nPuts the config d into path\n\nsource\n\n\n\n\n pcfg (d, path='/', method='post')\n\nPuts the config d into path\n\npcfg({})\n\n\nsource\n\n\n\n\n nested_setdict (sd, value, *keys)\n\nReturns sd updated to set value at the path keys\n\nnested_setdict({'a':'b'}, {'c':'d'}, 'apps', 'http', 'servers', 'srv0')\n\n{'a': 'b', 'apps': {'http': {'servers': {'srv0': {'c': 'd'}}}}}\n\n\n\nsource\n\n\n\n\n path2keys (path)\n\nSplit path by ‘/’ into a list\n\npath2keys('/apps/tls/automation/policies')\n\n['apps', 'tls', 'automation', 'policies']\n\n\n\nsource\n\n\n\n\n keys2path (*keys)\n\nJoin keys into a ‘/’ separated path\n\nkeys2path('apps', 'tls', 'automation', 'policies')\n\n'/apps/tls/automation/policies'\n\n\n\nsource\n\n\n\n\n nested_setcfg (value, *keys)\n\n\nsource\n\n\n\n\n init_path (path, skip=0)\n\n\n\n\n\n\ncf_token = os.environ['AAI_CF_TOKEN']\n\n\nsource\n\n\n\n get_acme_config (token)\n\n\nsource\n\n\n\n\n add_acme_config (cf_token)\n\n\nadd_acme_config(cf_token)\n\n\ngcfg('/apps/tls/automation/policies')[0]\n\n{ 'issuers': [{'challenges': {'dns': {'provider': {'api_token': 'yxeyTR9lZY9e265KHtoVjhMI23lh586PLBz1NxaA', 'name': 'cloudflare'}}}, 'module': 'acme'}]}\n\n\n\n\n\n\n\nsource\n\n\n\n init_routes (srv_name='srv0')\n\nCreate basic http server/routes config\n\ninit_routes()\n\n\nsource\n\n\n\n\n setup_caddy (cf_token, srv_name='srv0')\n\nCreate SSL config and HTTP app skeleton\n\ngcfg(srvs_path)\n\n{'srv0': {'listen': [':80', ':443'], 'routes': []}}\n\n\n\nsource\n\n\n\n\n add_route (route)\n\nAdd route dict to config\n\nsource\n\n\n\n\n del_id (id)\n\nDelete route for id (e.g. a host)\n\n# del_id(host)\n\n\nsource\n\n\n\n\n add_reverse_proxy (from_host, to_url)\n\nCreate a reverse proxy handler\n\nadd_reverse_proxy(host, \"localhost:5001\")\n\n\ngcfg(rts_path)\n\n(#1) [{'@id': 'jph.answer.ai', 'handle': [{'handler': 'reverse_proxy', 'upstreams': [{'dial': 'localhost:5001'}]}], 'match': [{'host': ['jph.answer.ai']}], 'terminal': True}]\n\n\n\ngid(host)\n\n{ '@id': 'jph.answer.ai',\n  'handle': [{'handler': 'reverse_proxy', 'upstreams': [{'dial': 'localhost:5001'}]}],\n  'match': [{'host': ['jph.answer.ai']}],\n  'terminal': True}",
    "crumbs": [
      "API"
    ]
  },
  {
    "objectID": "core.html#initial-functions",
    "href": "core.html#initial-functions",
    "title": "API",
    "section": "",
    "text": "source\n\n\n\n get_id (path)\n\nGet a ID full URL from a path\n\nhost = 'jph.answer.ai'\n\n\nget_id('jph.answer.ai')\n\n'http://localhost:2019/id/jph.answer.ai/'\n\n\n\nsource\n\n\n\n\n get_path (path)\n\nGet a config full URL from a path\n\nget_path('/apps/tls/automation/policies')\n\n'http://localhost:2019/config/apps/tls/automation/policies/'\n\n\n\nsource\n\n\n\n\n gid (path='/')\n\nGets the id at path\n\nsource\n\n\n\n\n has_id (id)\n\nCheck if id is set up\n\nsource\n\n\n\n\n gcfg (path='/', method='get')\n\nGets the config at path\n\nsource\n\n\n\n\n has_path (path)\n\nCheck if path is set up\n\ngcfg()\n\n{ 'apps': { 'tls': { 'automation': { 'policies': [{'issuers': [{'challenges': {'dns': {'provider': {'api_token': 'yxeyTR9lZY9e265KHtoVjhMI23lh586PLBz1NxaA', 'name': 'cloudflare'}}}, 'module': 'acme'}]}]}}}}\n\n\n\nsource\n\n\n\n\n pid (d, path='/', method='post')\n\nPuts the config d into path\n\nsource\n\n\n\n\n pcfg (d, path='/', method='post')\n\nPuts the config d into path\n\npcfg({})\n\n\nsource\n\n\n\n\n nested_setdict (sd, value, *keys)\n\nReturns sd updated to set value at the path keys\n\nnested_setdict({'a':'b'}, {'c':'d'}, 'apps', 'http', 'servers', 'srv0')\n\n{'a': 'b', 'apps': {'http': {'servers': {'srv0': {'c': 'd'}}}}}\n\n\n\nsource\n\n\n\n\n path2keys (path)\n\nSplit path by ‘/’ into a list\n\npath2keys('/apps/tls/automation/policies')\n\n['apps', 'tls', 'automation', 'policies']\n\n\n\nsource\n\n\n\n\n keys2path (*keys)\n\nJoin keys into a ‘/’ separated path\n\nkeys2path('apps', 'tls', 'automation', 'policies')\n\n'/apps/tls/automation/policies'\n\n\n\nsource\n\n\n\n\n nested_setcfg (value, *keys)\n\n\nsource\n\n\n\n\n init_path (path, skip=0)",
    "crumbs": [
      "API"
    ]
  },
  {
    "objectID": "core.html#acme-setup",
    "href": "core.html#acme-setup",
    "title": "API",
    "section": "",
    "text": "cf_token = os.environ['AAI_CF_TOKEN']\n\n\nsource\n\n\n\n get_acme_config (token)\n\n\nsource\n\n\n\n\n add_acme_config (cf_token)\n\n\nadd_acme_config(cf_token)\n\n\ngcfg('/apps/tls/automation/policies')[0]\n\n{ 'issuers': [{'challenges': {'dns': {'provider': {'api_token': 'yxeyTR9lZY9e265KHtoVjhMI23lh586PLBz1NxaA', 'name': 'cloudflare'}}}, 'module': 'acme'}]}",
    "crumbs": [
      "API"
    ]
  },
  {
    "objectID": "core.html#route-setup",
    "href": "core.html#route-setup",
    "title": "API",
    "section": "",
    "text": "source\n\n\n\n init_routes (srv_name='srv0')\n\nCreate basic http server/routes config\n\ninit_routes()\n\n\nsource\n\n\n\n\n setup_caddy (cf_token, srv_name='srv0')\n\nCreate SSL config and HTTP app skeleton\n\ngcfg(srvs_path)\n\n{'srv0': {'listen': [':80', ':443'], 'routes': []}}\n\n\n\nsource\n\n\n\n\n add_route (route)\n\nAdd route dict to config\n\nsource\n\n\n\n\n del_id (id)\n\nDelete route for id (e.g. a host)\n\n# del_id(host)\n\n\nsource\n\n\n\n\n add_reverse_proxy (from_host, to_url)\n\nCreate a reverse proxy handler\n\nadd_reverse_proxy(host, \"localhost:5001\")\n\n\ngcfg(rts_path)\n\n(#1) [{'@id': 'jph.answer.ai', 'handle': [{'handler': 'reverse_proxy', 'upstreams': [{'dial': 'localhost:5001'}]}], 'match': [{'host': ['jph.answer.ai']}], 'terminal': True}]\n\n\n\ngid(host)\n\n{ '@id': 'jph.answer.ai',\n  'handle': [{'handler': 'reverse_proxy', 'upstreams': [{'dial': 'localhost:5001'}]}],\n  'match': [{'host': ['jph.answer.ai']}],\n  'terminal': True}",
    "crumbs": [
      "API"
    ]
  }
]